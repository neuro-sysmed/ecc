#!/usr/bin/env python3
# 
# 
# 
# 

import pprint
import sys
import os

pp = pprint.PrettyPrinter(indent=4)
import time
import argparse
from munch import Munch

import kbr.config_utils as config_utils
import kbr.log_utils as logger
import kbr.args_utils as args_utils
import kbr.version_utils as version_utils

sys.path.append(".")
import ecc
import ecc.slurm_utils as slurm_utils
import ecc.cloudflare_utils as cloudflare_utils
import ecc.ansible_utils as ansible_utils


version = version_utils.as_string('ecc')
config = None
program_name = 'eccd'

IDLE_TIME = 300


def init(args):
    global config
    if args.config and os.path.isfile( args.config ):
        config = config_utils.readin_config_file(args.config)
        logger.init(name=program_name, log_file=config.ecc.get('logfile', None))
        logger.set_log_level(args.verbose)
        logger.info(f'{program_name} (v:{version})')
        if 'name_template' in config.ecc:
            config.ecc.name_regex = config.ecc.name_template.format("(\d+)")
        elif 'queues' not in config:
            print("Need to configure either a single ecc.name_regex or define some queues")
            sys.exit(1)
        else:
            for queue in config.queues:
                config.queues[queue].name_regex = config.queues[queue].name_template.format("(\d+)")


        ecc.set_config(config)
        if 'openstack' in config:
            ecc.openstack_connect(config.openstack)
        elif 'azure' in config:
            ecc.azure_connect( config.azure )
        else:
            print('No backend configured, options are: openstack and azure')
        
        if 'cloudflare' in config.ecc:
            cloudflare_utils.init(config.ecc.cloudflare_apikey, config.ecc.cloudflare_email)
    else:
        logger.init(name=program_name)
        logger.set_log_level(args.verbose)
        logger.info(f'{program_name} (v:{version})')


def update_partition(partition:str=None):
    ecc.slurm_idle_drained_nodes()

    nodes_total = ecc.nodes_total()
    unregistered_nodes = ecc.unregistered_nodes()
    nodes_idle = ecc.nodes_idle_timelimit(limit=IDLE_TIME)
    jobs_pending = slurm_utils.jobs_pending()
    pending_time = slurm_utils.pending_time()

    if partition is not None:
        print( f"Updating {partition}")

    print(f"nodes_total: {nodes_total}, nodes_idle: {len(nodes_idle)}, jobs_pending: {jobs_pending}")
    print(f"mean pending time: {pending_time['pending_mean']}, max pending time: {pending_time['max']}")

    # this should not happen anymore as we wait for the server to come online before running the ecc-playbook
    if unregistered_nodes != []:
        logger.info('running playbook to pickup missing nodes...')
        ansible_utils.run_playbook(config.ecc.ansible_cmd, cwd=config.ecc.ansible_dir)

        # Below the min number of nodes needed for our setup
    elif nodes_total < config.ecc.nodes_min:
        logger.info("We are below the min number of nodes, creating {} nodes".format(
        config.ecc.nodes_min - nodes_total))

        ecc.create_nodes(count=config.ecc.nodes_min - nodes_total)

    ### there are jobs queuing, let see what we should do
    # Got room to make some additional nodes
    elif jobs_pending and pending_time['pending_mean'] >= IDLE_TIME and nodes_total < int(config.ecc.nodes_max):

        logger.info("We got stuff to do and long pending times, creating an additional node...")
        ecc.create_nodes(count=1)

    # We got extra nodes not needed and we can delete some without going under the min cutoff, so lets get rid of some
    elif nodes_idle:


        logger.info(f"Deleting {nodes_idle} idle nodes... ")
        ecc.delete_idle_nodes(nodes_to_cull=nodes_idle)

    else:
        logger.info("Nothing to change.")



def run_daemon() -> None:
    """ Creates the ecc daemon loop that creates and destroys nodes etc.
    """


    while (True):
        # get the current number of nodes and jobs
        ecc.update_nodes_status()

        # pretty hackey, but if no queues defined, run with "default"
        for queue in config.get('queues', [None]):
            update_partition( partition=queue )

        logger.info("Napping for {} second(s).".format(config.ecc.sleep))
        time.sleep(config.ecc.sleep)





def main():

    parser = argparse.ArgumentParser(description='eccd: the ecc daemon to be run on the master node ')
    parser.add_argument('-l', '--logfile', default=None, help="Logfile to write to, default is stdout")
    parser.add_argument('-v', '--verbose', default=4, action="count", help="Increase the verbosity of logging output")
    parser.add_argument('-c', '--config', help="ECC config file",
                        default=args_utils.get_env_var('ECC_CONF','ecc.yaml')) 

    args = parser.parse_args()
    init(args)
    run_daemon()


if __name__ == '__main__':
    main()
else:
    print("Not to be run as a library")
    sys.exit(1)
